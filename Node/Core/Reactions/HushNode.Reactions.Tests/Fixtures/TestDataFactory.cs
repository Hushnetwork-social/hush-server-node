using System.Numerics;
using HushShared.Feeds.Model;
using HushShared.Reactions.Model;
using HushNode.Reactions.Crypto;
using HushNode.Reactions.Storage;

namespace HushNode.Reactions.Tests.Fixtures;

/// <summary>
/// Factory for creating test data used across multiple tests.
/// </summary>
public static class TestDataFactory
{
    private static readonly BabyJubJubCurve Curve = new();
    private static readonly Random Random = new(42); // Deterministic for reproducibility

    public static FeedId CreateFeedId() => new(Guid.NewGuid());

    public static FeedMessageId CreateMessageId() => new(Guid.NewGuid());

    public static byte[] CreateCommitment()
    {
        var bytes = new byte[32];
        Random.NextBytes(bytes);
        return bytes;
    }

    public static byte[] CreateNullifier()
    {
        var bytes = new byte[32];
        Random.NextBytes(bytes);
        return bytes;
    }

    public static byte[] CreateZkProof()
    {
        // Fake proof - real proofs are ~256 bytes
        var bytes = new byte[256];
        Random.NextBytes(bytes);
        return bytes;
    }

    public static ECPoint CreateIdentityPoint() => Curve.Identity;

    public static ECPoint CreateRandomPoint()
    {
        // Use generator point scaled by random scalar
        var gx = BigInteger.Parse("5299619240641551281634865583518297030282874472190772894086521144482721001553");
        var gy = BigInteger.Parse("16950150798460657717958625567821834550301663161624707787222815936182638968203");
        var generator = new ECPoint(gx, gy);

        var scalar = new BigInteger(Random.Next(1, 1000000));
        return Curve.ScalarMul(generator, scalar);
    }

    public static ECPoint[] CreateCiphertextArray(int count = 6)
    {
        return Enumerable.Range(0, count)
            .Select(_ => CreateRandomPoint())
            .ToArray();
    }

    public static byte[][] CreateByteArrays(int count = 6, int size = 32)
    {
        return Enumerable.Range(0, count)
            .Select(_ =>
            {
                var bytes = new byte[size];
                Random.NextBytes(bytes);
                return bytes;
            })
            .ToArray();
    }

    public static MessageReactionTally CreateEmptyTally(FeedId feedId, FeedMessageId messageId, long version = 1)
    {
        var identity = CreateIdentityPoint();
        var identityX = PadTo32Bytes(identity.X.ToByteArray(isUnsigned: true, isBigEndian: true));
        var identityY = PadTo32Bytes(identity.Y.ToByteArray(isUnsigned: true, isBigEndian: true));

        return new MessageReactionTally(
            MessageId: messageId,
            FeedId: feedId,
            TallyC1X: Enumerable.Repeat(identityX, 6).ToArray(),
            TallyC1Y: Enumerable.Repeat(identityY, 6).ToArray(),
            TallyC2X: Enumerable.Repeat(identityX, 6).ToArray(),
            TallyC2Y: Enumerable.Repeat(identityY, 6).ToArray(),
            TotalCount: 0,
            Version: version,
            LastUpdated: DateTime.UtcNow);
    }

    public static MessageReactionTally CreateTallyWithVotes(FeedId feedId, FeedMessageId messageId, int voteCount, long version = 1)
    {
        var tally = CreateEmptyTally(feedId, messageId, version);

        // Simulate adding votes by using random points
        var c1x = CreateByteArrays(6, 32);
        var c1y = CreateByteArrays(6, 32);
        var c2x = CreateByteArrays(6, 32);
        var c2y = CreateByteArrays(6, 32);

        return tally with
        {
            TallyC1X = c1x,
            TallyC1Y = c1y,
            TallyC2X = c2x,
            TallyC2Y = c2y,
            TotalCount = voteCount
        };
    }

    public static ReactionNullifier CreateNullifierRecord(FeedMessageId messageId)
    {
        return new ReactionNullifier(
            Nullifier: CreateNullifier(),
            MessageId: messageId,
            VoteC1X: CreateByteArrays(6, 32),
            VoteC1Y: CreateByteArrays(6, 32),
            VoteC2X: CreateByteArrays(6, 32),
            VoteC2Y: CreateByteArrays(6, 32),
            EncryptedEmojiBackup: CreateCommitment(),
            CreatedAt: DateTime.UtcNow,
            UpdatedAt: DateTime.UtcNow);
    }

    public static FeedMemberCommitment CreateMemberCommitment(FeedId feedId)
    {
        return new FeedMemberCommitment(
            FeedId: feedId,
            UserCommitment: CreateCommitment(),
            RegisteredAt: DateTime.UtcNow);
    }

    public static MerkleRootHistory CreateMerkleRootHistory(FeedId feedId, long blockHeight = 100)
    {
        return new MerkleRootHistory(
            Id: 0,  // Auto-generated by database
            FeedId: feedId,
            MerkleRoot: CreateCommitment(),
            BlockHeight: blockHeight,
            CreatedAt: DateTime.UtcNow);
    }

    public static HushNode.Reactions.Storage.SubmitReactionRequest CreateSubmitRequest(FeedId? feedId = null, FeedMessageId? messageId = null)
    {
        return new HushNode.Reactions.Storage.SubmitReactionRequest
        {
            FeedId = feedId ?? CreateFeedId(),
            MessageId = messageId ?? CreateMessageId(),
            Nullifier = CreateNullifier(),
            CiphertextC1 = CreateCiphertextArray(),
            CiphertextC2 = CreateCiphertextArray(),
            ZkProof = CreateZkProof(),
            EncryptedEmojiBackup = CreateCommitment(),
            CircuitVersion = "omega-v1.0.0"
        };
    }

    private static byte[] PadTo32Bytes(byte[] input)
    {
        if (input.Length >= 32)
            return input[..32];

        var result = new byte[32];
        Array.Copy(input, 0, result, 32 - input.Length, input.Length);
        return result;
    }
}
