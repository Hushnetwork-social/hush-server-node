using FluentAssertions;
using SkiaSharp;
using Xunit;

namespace HushNode.IntegrationTests.Infrastructure;

/// <summary>
/// Unit tests for TestImageGenerator - verifies labeled test images are valid PNGs
/// with correct file naming and different colors per index.
/// </summary>
public class TestImageGeneratorTests
{
    [Fact]
    public void GenerateTestAttachment_ShouldReturnCorrectFileName()
    {
        // Act
        var (fileName, _) = TestImageGenerator.GenerateTestAttachment(1, "Alice", "Bob");

        // Assert
        fileName.Should().Be("Image-1-from-Alice-to-Bob.png");
    }

    [Fact]
    public void GenerateTestAttachment_ShouldReturnDifferentFileNamePerIndex()
    {
        // Act
        var (fileName1, _) = TestImageGenerator.GenerateTestAttachment(1, "Alice", "Bob");
        var (fileName2, _) = TestImageGenerator.GenerateTestAttachment(2, "Alice", "Bob");

        // Assert
        fileName1.Should().NotBe(fileName2);
        fileName2.Should().Be("Image-2-from-Alice-to-Bob.png");
    }

    [Fact]
    public void GenerateTestAttachment_ShouldReturnValidPng()
    {
        // Act
        var (_, pngBytes) = TestImageGenerator.GenerateTestAttachment(1, "Alice", "Bob");

        // Assert - should be decodable as a valid image
        using var bitmap = SKBitmap.Decode(pngBytes);
        bitmap.Should().NotBeNull("Generated bytes should be a valid PNG");
        bitmap!.Width.Should().Be(400);
        bitmap.Height.Should().Be(200);
    }

    [Fact]
    public void GenerateTestAttachment_ShouldProduceDifferentImagesPerIndex()
    {
        // Act
        var (_, bytes1) = TestImageGenerator.GenerateTestAttachment(1, "Alice", "Bob");
        var (_, bytes2) = TestImageGenerator.GenerateTestAttachment(2, "Alice", "Bob");

        // Assert - different index = different color = different bytes
        bytes1.Should().NotBeEquivalentTo(bytes2,
            "Different image indices should produce different colored images");
    }

    [Fact]
    public void GenerateTestAttachment_ShouldSupportGroupTargetNames()
    {
        // Act
        var (fileName, pngBytes) = TestImageGenerator.GenerateTestAttachment(3, "Alice", "Open Forum");

        // Assert
        fileName.Should().Be("Image-3-from-Alice-to-Open Forum.png");
        pngBytes.Should().NotBeEmpty();

        // Should still be a valid PNG
        using var bitmap = SKBitmap.Decode(pngBytes);
        bitmap.Should().NotBeNull();
    }

    [Fact]
    public void GenerateTestAttachment_ShouldProduceReasonablySizedBytes()
    {
        // Act
        var (_, pngBytes) = TestImageGenerator.GenerateTestAttachment(1, "Alice", "Bob");

        // Assert - 400x200 PNG with simple graphics should be under 50KB
        pngBytes.Length.Should().BeGreaterThan(100, "Should not be trivially small");
        pngBytes.Length.Should().BeLessThan(50_000, "Simple labeled PNG should be under 50KB");
    }

    // =========================================================================
    // Animated GIF tests
    // =========================================================================

    [Fact]
    public void GenerateAnimatedTestGif_ShouldReturnCorrectFileName()
    {
        var (fileName, _) = TestImageGenerator.GenerateAnimatedTestGif(1, "Alice", "Bob");
        fileName.Should().Be("Animated-1-from-Alice-to-Bob.gif");
    }

    [Fact]
    public void GenerateAnimatedTestGif_ShouldReturnValidGif89a()
    {
        var (_, gifBytes) = TestImageGenerator.GenerateAnimatedTestGif(1, "Alice", "Bob");

        // GIF89a header
        gifBytes.Length.Should().BeGreaterThan(20, "Should not be trivially small");
        gifBytes[0].Should().Be((byte)'G');
        gifBytes[1].Should().Be((byte)'I');
        gifBytes[2].Should().Be((byte)'F');
        gifBytes[3].Should().Be((byte)'8');
        gifBytes[4].Should().Be((byte)'9');
        gifBytes[5].Should().Be((byte)'a');

        // Trailer
        gifBytes[^1].Should().Be(0x3B, "GIF should end with trailer byte 0x3B");
    }

    [Fact]
    public void GenerateAnimatedTestGif_ShouldContainNetscapeLoopExtension()
    {
        var (_, gifBytes) = TestImageGenerator.GenerateAnimatedTestGif(1, "Alice", "Bob");

        // Search for NETSCAPE2.0 string in the bytes
        var netscape = System.Text.Encoding.ASCII.GetBytes("NETSCAPE2.0");
        var found = false;
        for (var i = 0; i <= gifBytes.Length - netscape.Length; i++)
        {
            if (gifBytes.AsSpan(i, netscape.Length).SequenceEqual(netscape))
            {
                found = true;
                break;
            }
        }

        found.Should().BeTrue("Animated GIF should contain NETSCAPE2.0 loop extension");
    }

    [Fact]
    public void GenerateAnimatedTestGif_ShouldBeDecodableBySkiaSharp()
    {
        var (_, gifBytes) = TestImageGenerator.GenerateAnimatedTestGif(1, "Alice", "Bob");

        // Use SKCodec (designed for multi-frame images) rather than SKBitmap.Decode
        using var skData = SKData.CreateCopy(gifBytes);
        using var codec = SKCodec.Create(skData);

        if (codec != null)
        {
            // SKCodec can parse the GIF structure
            codec.Info.Width.Should().Be(50);
            codec.Info.Height.Should().Be(50);
            codec.FrameCount.Should().Be(3, "Animated GIF should have 3 frames");
        }
        else
        {
            // If SKCodec can't parse it, at least verify the binary structure
            // (the E2E browser test is the real validation)
            gifBytes.Length.Should().BeGreaterThan(100, "GIF should have substantial content");
            Console.WriteLine($"[TestImageGenerator] SKCodec returned null for animated GIF ({gifBytes.Length} bytes)");
            Console.WriteLine("[TestImageGenerator] Will rely on E2E browser test for validation");
        }
    }
}
